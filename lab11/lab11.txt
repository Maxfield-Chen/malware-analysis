Lab 11: Maxfield Chen

1. 
  -Driver Entry Address: 00058D05
  -IRP Dispatch Handlers
    -IRP_MJ_PNP
    -IRP_MJ_POWER
    -IRP_MJ_CREATE
    -IRP_MJ_CLOSE
    -IRP_MJ_DEVICE_CONTROL (IOCTL)
2. 
  -Call to ioattachdevicetodevicestack at 00013895, used in the AddDevice Handler
  -This driver doesn't really filter or intercept anything, it's only attach call is used on itself to satisfy the PNP requirements.
3.
  -Call to createDevice at 00013BB9
  -Device Extension Size: 16
  -Device Name: NDISKPRO
4.
  -In this case, it's a structure with 4 integers, all set to zero except the first which is set to one.
5. IO Methods
  -METHOD_BUFFERED 
  -One of them is used to test for VM by testing for a keyboard response. Crashes VM if no physical keyboard exists.
6.
  -2 DPC's
  -No APCS
  -Timers at:
    -00013D7F
    -00013E41
    Each of them are linked with a DPC Routine to be executed 1000000 system units after timer is set.
  -Create New System thread at:
    -00013F15
  -For callbacks and other assorted things, see the included Ida Database file.
7.
On the very highest of levels, this driver provides the ability to keylog and attempt to crash a virtual machine through IOCTL commands; it uses DPC routines to set IDT table entries which correspond to breakpoints such that they will crash the system when executed, and finally has a nice debug function which comes from a spawned system thread which prints useful information. 

Detailed analysis of each aspect of the malware:
  First IOCTL Sets up the ability to do the following: 
    Expect an 8042 Keyboard Controller. Send Code 0xED to Port 0x60
      -This is an ANTI VM Technique, waits for physical keyboard to report status and will hang forever if it doesn't recieve it.
    There is also something which looks an awful lot like an KeyLogger triggered by IOCTL code.
  Then the first DPC executes after a 1000000 system unit delay set by a timer.
    -This DPC messes with the IDT table and debug registers. I believe it's ultimate purpose is to interfere with usermode debugging attempts.
      -Can be called with an argument which either resets or activates its modifications
      -If activated in nonmalicious mode, then it simply restores CR4 and DR012,7 registers to a sane default.
      -If called in malicious mode, it will change those registers such that any of the dr0-2 registers will trigger or read or write.
        -Next it will mess with the predefined breakpoint entry in the IDT such that it points to a new malicious function.
        -Finally it defines a user entry in the IDT at 0x255. It will return a pointer to this new entry.
  The second DPC is now executed on another 1000000 system unit timer.
    -This DPC seems to do something a little different. It checks to see if the custom breakpoint code set by the first DPC has been executed by setting a breakpoint in the dr2 register.
      -If it is inside that interrupt, than it turns off write protection by modifying cr0 then changes the address at IDT[3] which corresponds to the breakpoint entry. 
      -This time it will set the entry to a negative number causing a system crash on breakpoint execution.
  Finally after both of the DPC's have been setup, it spawns a new system thread:
    -This thread is used for debugging purposes, it uses dbgprint to display information about validity of generated HID Report
    -It also has a subroutine which elevates IRQL to 2 so that it can print out the current IDT entry at 0x03, current ISR, and relevant registers (dr0-3,6,7)
