Lab6.exe
-1 Address of Main: 00403420
  -GetCommandLineA: Retrieves the command-line string for the current process.
  -GetStartupInfoA: Retrieves the contents of the STARTUPINFO structure that was specified when the calling process was created.
  -GetModuleHandleA: Retrieves a module handle for the specified module. The module must have been loaded by the calling process.
  -It should be noted that these are being used to get a handle to the current process and alter the startup info such that wShowWindow is set to hide. This is a measure meant to prevent detection. GetCommandLineA is parsed to remove whitespace and the results are passed into an encoding function along with a handle to the current process and the shown window state.
-2
 A: Yes, there is an encoding / decoding function.
  -The address of the function is: 004012EC
  -Pieces of information used to identify functions and libraries for later discreet loading.
 B: It's calling the decoding function with parameters for each of the strings it wishes to decode and then copying them together when necessary. Of note is that it uses the string 'BadJoke' as an argument to the decoding function every time. Once all the function indentifiers have been decoded, it calls another function to load each of them into memory.
-3
  A: They're discreetly retreiving the addresses to a variety of functions using the decoded data.
  B: This function is called after the decoding occurs, it's used to load in a bunch of libraries without having them show up on any import lists. It takes decoded strings, finds the addresses of the corresponding function and loads those functions and libaries into memory.
-4 
This program starts by getting the command line and startup information and formatting the commandline string to strip whitespace, and modifying the startup info to hide the current window. Loading the libraries ntdll.dll, advapi32.dll. Then it calls getProcAddress to find VirtualAlloc and VirtualAllocEx. It continues to use getProcAddress to find getModuleFileName, NtUnMapViewOfSection, FreeLibrary, TerminateProcess, CreateProcess, SetThreadContext, GetThreadContext, ResumeThread, ReadProcessMemory, VirtualQueryEx, VirtualProtectEx, VirtualFree, WriteProcessMemory, CloseHandle, GetLocalTime, Sleep, RtlCompressBuffer, RtlDecompressBuffer, ntdll_RtlGetCompressionWorkSpaceSize, kernel32_CreateFileA, kernel32_ReadFile, kernel32_SetFilePointer, kernel32_GetFileSizeEx, advapi32_GetUserNameA, advapi32_RegOpenKeyA, advapi32_RegQueryValueExA, advapi32_RegCloseKey. Note that none of this huge functionality set was visible from the import list. 

Next, if all libraries were loaded successfully, it calls a function which attempts to get a module handle to itself, but then closes it, incorrectly resulting in an exception. After the exception is handled, the program goes on to open an existing file, allocates space and sets a file pointer at the start of the file, then reads data from that file, finally closing the handle to that file. I was then passed to a giant conditional block which determined me unworthy and promptly exited the program. Interestingly, it seems that this exception is not encountered when the program is run manually. A quick googling of the close handle command reveals that it actually is used in anti-malware techniques. 

Finally, after it deals with the exception, it allocates some space for a file, and calls a massive function with more decoding. From here I had a very difficult time continuing my analysis. Despite labeling almost all the functions and breaking down what they did, I was unable to find where the handle to this allocated file was used. Dynamic analysis proved equally unhelpful, there were no registry changes and no files written despite the allocated space. Eventually I had a breakthrough and realized that the file handle was actually pointing towards the very same executable! After examining the file postrun, it does appear that the file checksum no longer matches. So the file is self modifying, but not in a way which appears malicious. FileAlyzer reports 116 bytes after the last section. Investigation of these bytes reveals this string: 
§U§NICK{Xertircbot§-serenity.ix.us.dal.net§-6667§-#doitonda #doitonda§-hackme§-%WINDIR%§-server§-%WINDIR%§-NICK{§U§U
This would be a perfect host based signature which should help greatly in tracking down whoever distributed this malicious file.
